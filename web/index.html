<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Biblioteca Zotero - NeuropediaLab</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
            background-color: #fff;
            color: #111;
            line-height: 1.6;
        }
        
        .header {
            background: #0073aa;
            color: white;
            padding: 2rem 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
            border-bottom: 3px solid #005177;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .title-area h1 {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            letter-spacing: -0.5px;
        }
        
        .title-area p {
            opacity: 0.95;
            font-size: 1rem;
            font-weight: 400;
        }
        
        .compact-stats {
            display: flex;
            gap: 1.5rem;
            align-items: center;
        }
        
        .stat-mini {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255,255,255,0.2);
            padding: 0.75rem 1.25rem;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.3);
            min-width: 110px;
        }
        
        .stat-icon {
            font-size: 1.3rem;
        }
        
        .stat-content {
            display: flex;
            flex-direction: column;
        }
        
        .stat-number {
            font-size: 1.1rem;
            font-weight: 700;
            line-height: 1;
        }
        
        .stat-label {
            font-size: 0.7rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .sync-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            opacity: 0.9;
        }
        
        .sync-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #46b450;
            animation: pulse 2s infinite;
        }
        
        .sync-indicator.indexing {
            background: #f0b849;
            animation: spin 1s linear infinite;
        }
        
        .sync-indicator.error {
            background: #d63638;
            animation: none;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2.5rem 2rem;
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 2.5rem;
            height: calc(100vh - 130px);
            background: #f9f9f9;
        }
        
        .navigation-panel {
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .nav-header {
            background: #f9f9f9;
            padding: 1.25rem;
            border-bottom: 1px solid #ddd;
        }
        
        .nav-search {
            width: 100%;
            padding: 0.625rem 0.875rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9375rem;
            font-family: inherit;
            transition: border-color 0.2s;
        }
        
        .nav-search:focus {
            outline: none;
            border-color: #0073aa;
        }
        
        .folder-tree {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .tree-item {
            margin: 0.2rem 0;
        }
        
        .tree-folder, .tree-file {
            display: flex;
            align-items: center;
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.15s;
            color: #111;
        }
        
        .tree-folder:hover, .tree-file:hover {
            background-color: #f9f9f9;
        }
        
        .tree-folder.expanded {
            background-color: #f0f6fc;
            border-left: 2px solid #0073aa;
        }
        
        .tree-icon {
            margin-right: 0.5rem;
            width: 16px;
            text-align: center;
        }
        
        .pdf-count {
            opacity: 0.6;
            font-size: 0.875em;
            margin-left: 0.3rem;
            color: #767676;
        }
        
        .tree-children {
            margin-left: 1rem;
            border-left: 1px solid #ddd;
            padding-left: 0.5rem;
            display: none;
        }
        
        .tree-children.expanded {
            display: block;
        }
        
        .file-indexed {
            color: #0073aa;
        }
        
        .file-not-indexed {
            color: #767676;
        }
        
        .tree-item-content {
            display: flex;
            align-items: center;
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.15s;
            color: #111;
        }
        
        .tree-item-content:hover {
            background-color: #f9f9f9;
        }
        
        .tree-item-content.selected {
            background-color: #f0f6fc;
            border-left: 3px solid #0073aa;
        }
        
        .expand-icon {
            display: inline-block;
            width: 1rem;
            margin-right: 0.3rem;
            cursor: pointer;
            user-select: none;
        }
        
        .main-panel {
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .search-tabs {
            display: flex;
            background: #f9f9f9;
            border-bottom: 1px solid #ddd;
        }
        
        .tab {
            padding: 1rem 1.75rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            font-weight: 600;
            color: #767676;
            font-size: 0.9375rem;
        }
        
        .tab:hover {
            background: #f0f0f0;
            color: #111;
        }
        
        .tab.active {
            background: white;
            border-bottom-color: #0073aa;
            color: #0073aa;
        }
        
        .search-content {
            padding: 2rem;
            flex: 1;
            overflow-y: auto;
        }
        
        .search-box {
            margin-bottom: 2rem;
        }
        
        .search-input {
            width: 100%;
            padding: 0.875rem 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
            font-family: inherit;
            transition: border-color 0.2s;
            color: #111;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #0073aa;
            box-shadow: 0 0 0 1px #0073aa;
        }
        
        .results {
            margin-top: 1rem;
        }
        
        .result-item {
            background: #f9f9f9;
            border-radius: 4px;
            padding: 1.25rem;
            margin-bottom: 1rem;
            border-left: 3px solid #0073aa;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid #ddd;
            border-left: 3px solid #0073aa;
        }
        
        .result-item:hover {
            background: #fff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }
        
        .result-title {
            font-weight: 700;
            margin-bottom: 0.625rem;
            color: #111;
            font-size: 1.0625rem;
            line-height: 1.4;
        }
        
        .result-context {
            font-size: 0.9375rem;
            color: #767676;
            line-height: 1.6;
        }
        
        .result-path {
            font-size: 0.875rem;
            color: #767676;
            margin-top: 0.625rem;
            padding-top: 0.625rem;
            border-top: 1px solid #eee;
        }
        
        .loading {
            text-align: center;
            padding: 3rem 2rem;
            color: #767676;
            font-size: 1rem;
        }
        
        .error-message {
            text-align: center;
            padding: 2rem;
            color: #d63638;
            background: #fef7f7;
            border-radius: 4px;
            border: 1px solid #f8d7da;
            margin: 1rem 0;
        }
        
        .no-results {
            text-align: center;
            padding: 3rem 2rem;
            color: #767676;
            font-size: 1rem;
        }
        
        .progress-bar {
            height: 4px;
            background: #ddd;
            border-radius: 2px;
            margin: 0.5rem 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: #0073aa;
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        .status-message {
            font-size: 0.875rem;
            color: #767676;
            margin-top: 0.625rem;
        }
        
        .api-info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #005177;
            color: white;
            padding: 0.625rem 1.125rem;
            border-radius: 4px;
            font-size: 0.875rem;
            opacity: 0.9;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        /* Estilos para botones */
        button {
            font-family: inherit;
            font-size: 0.875rem;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #ddd;
            background: white;
            color: #111;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #f9f9f9;
            border-color: #0073aa;
            color: #0073aa;
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        /* Enlaces */
        a {
            color: #0073aa;
            text-decoration: none;
            transition: color 0.2s;
        }
        
        a:hover {
            color: #005177;
            text-decoration: underline;
        }
        
        /* Estilo para badges/etiquetas */
        .badge {
            display: inline-block;
            padding: 0.25rem 0.625rem;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: 600;
            background: #f0f6fc;
            color: #0073aa;
            border: 1px solid #0073aa;
        }
        
        .badge.success {
            background: #f0f9f4;
            color: #46b450;
            border-color: #46b450;
        }
        
        .badge.warning {
            background: #fef8ee;
            color: #f0b849;
            border-color: #f0b849;
        }
        
        /* Scrollbar personalizado */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f9f9f9;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #ddd;
            border-radius: 6px;
            border: 2px solid #f9f9f9;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #0073aa;
        }
        
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                padding: 1.5rem 1rem;
                height: auto;
                gap: 1.5rem;
            }
            
            .navigation-panel {
                order: 2;
                max-height: 500px;
            }
            
            .header {
                padding: 1.5rem 1rem;
            }
            
            .header-content {
                flex-direction: column;
                align-items: flex-start;
                gap: 1.25rem;
            }
            
            .compact-stats {
                flex-wrap: wrap;
                width: 100%;
            }
            
            .stat-mini {
                flex: 1;
                min-width: 100px;
            }
            
            .title-area h1 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="title-area">
                <h1>üìö Biblioteca Zotero</h1>
                <p>NeuropediaLab - Gesti√≥n Inteligente de Documentos</p>
                <div class="sync-status">
                    <div class="sync-indicator" id="syncIndicator"></div>
                    <span id="syncStatus">Iniciando...</span>
                </div>
            </div>
            <div class="compact-stats">
                <div class="stat-mini">
                    <div class="stat-icon">üìÑ</div>
                    <div class="stat-content">
                        <div class="stat-number" id="totalPDFs">0</div>
                        <div class="stat-label">PDFs</div>
                    </div>
                </div>
                <div class="stat-mini">
                    <div class="stat-icon">üîç</div>
                    <div class="stat-content">
                        <div class="stat-number" id="indexedPDFs">0</div>
                        <div class="stat-label">Indexados</div>
                    </div>
                </div>
                <div class="stat-mini">
                    <div class="stat-icon">‚è±Ô∏è</div>
                    <div class="stat-content">
                        <div class="stat-number" id="lastSync">--</div>
                        <div class="stat-label">√öltima Sync</div>
                    </div>
                </div>
            </div>
            
            <!-- Barra de progreso de indexaci√≥n -->
            <div id="indexingProgress" style="display: none; margin-top: 1rem; padding: 1rem; background: #fff3cd; border-radius: 8px; border-left: 4px solid #ffc107;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                    <strong>üîç Indexando PDFs con OCR...</strong>
                    <span id="indexingPercentage">0%</span>
                </div>
                <div style="background: #e0e0e0; height: 20px; border-radius: 10px; overflow: hidden;">
                    <div id="indexingBar" style="background: linear-gradient(90deg, #4CAF50, #45a049); height: 100%; width: 0%; transition: width 0.3s;"></div>
                </div>
                <div style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">
                    <span id="indexingStatus">Preparando...</span>
                </div>
            </div>
            
            <!-- Bot√≥n de indexaci√≥n -->
            <div style="margin-top: 1rem; text-align: center;">
                <button id="startIndexingBtn" onclick="startIndexing()" style="padding: 0.7rem 1.5rem; background: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1rem; font-weight: 500; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    üöÄ Iniciar Indexaci√≥n OCR
                </button>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="navigation-panel">
            <div class="nav-header">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1rem; color: #2c3e50;">üìö Colecciones Zotero</h3>
                <input type="text" id="collectionSearch" class="nav-search" placeholder="üîç Buscar en colecciones e items...">
            </div>
            <div class="folder-tree" id="collectionTree">
                <div class="loading">Cargando colecciones...</div>
            </div>
        </div>

        <div class="main-panel">
            <div class="search-tabs">
                <div class="tab active" data-tab="database">üìö Base de Datos</div>
                <div class="tab" data-tab="search">üîç Buscar en Texto</div>
            </div>

            <div class="search-content">
                <div id="databaseTab" class="tab-content">
                    <div class="search-box">
                        <h3>üìö Base de Datos Zotero</h3>
                        <p style="font-size: 0.9rem; color: #7f8c8d;">
                            Navega por tu biblioteca usando el panel izquierdo. Selecciona carpetas para ver PDFs o colecciones para ver items de Zotero.
                            <br>üìÑ = PDF registrado (click para abrir) | üîó = URL disponible | ‚ö†Ô∏è = Sin PDF ni URL
                        </p>
                    </div>
                    <div id="databaseResults" class="results">
                        <div class="no-results">
                            Selecciona una carpeta o colecci√≥n en el panel de navegaci√≥n
                        </div>
                    </div>
                </div>

                <div id="searchTab" class="tab-content" style="display: none;">
                    <div class="search-box">
                        <input type="text" id="textSearch" class="search-input" 
                               placeholder="üîç Buscar en el contenido de los PDFs indexados...">
                        <p style="margin-top: 0.5rem; font-size: 0.9rem; color: #7f8c8d;">
                            Busca palabras o frases en el texto completo de todos los documentos PDF indexados.
                        </p>
                    </div>
                    <div id="indexingProgress" style="display: none;">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="status-message" id="progressMessage">Indexando documentos...</div>
                    </div>
                    <div id="searchResults" class="results"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="api-info" id="apiInfo" style="display: none;">
        APIs ocultas disponibles con API Key
    </div>

    <script>
        // Configuraci√≥n
        const API_BASE = window.location.origin;
        const RETRY_DELAY = 5000;
        const MAX_RETRIES = 3;
        
        // Variables globales
        let folderTree = {};
        let currentStats = {};
        let searchTimeout;
        let retryCount = 0;
        let socket;

        // Elementos DOM
        const elements = {
            syncIndicator: document.getElementById('syncIndicator'),
            syncStatus: document.getElementById('syncStatus'),
            totalPDFs: document.getElementById('totalPDFs'),
            indexedPDFs: document.getElementById('indexedPDFs'),
            lastSync: document.getElementById('lastSync'),
            textSearch: document.getElementById('textSearch'),
            searchResults: document.getElementById('searchResults'),
            databaseResults: document.getElementById('databaseResults'),
            indexingProgress: document.getElementById('indexingProgress'),
            progressFill: document.getElementById('progressFill'),
            progressMessage: document.getElementById('progressMessage'),
            apiInfo: document.getElementById('apiInfo')
        };

        // Sistema de estad√≠sticas simplificado v0.2 (sin Socket.IO)
        function initializeStats() {
            console.log('üìä Inicializando sistema estad√≠sticas REST...');
            
            // Cargar estad√≠sticas inmediatamente
            loadStatsManually();
            
            // Polling cada 15 segundos
            setInterval(() => {
                loadStatsManually();
            }, 15000);
            
            updateConnectionStatus('connected');
        }

        // Cargar estad√≠sticas manualmente via API REST
        async function loadStatsManually() {
            try {
                const response = await fetch(`${API_BASE}/api/stats`);
                if (response.ok) {
                    const stats = await response.json();
                    currentStats = stats;
                    updateStats(stats);
                    updateConnectionStatus('connected');
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                console.error('‚ùå Error cargando estad√≠sticas:', error);
                updateConnectionStatus('error');
            }
        }

        // Actualizar estado de conexi√≥n
        function updateConnectionStatus(status) {
            elements.syncIndicator.classList.remove('indexing', 'error');
            
            switch (status) {
                case 'connected':
                    elements.syncStatus.textContent = 'Conectado';
                    break;
                case 'disconnected':
                    elements.syncStatus.textContent = 'Desconectado';
                    elements.syncIndicator.classList.add('error');
                    break;
                case 'error':
                    elements.syncStatus.textContent = 'Error de conexi√≥n';
                    elements.syncIndicator.classList.add('error');
                    break;
            }
        }

        // Pesta√±as
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                switchTab(tabName);
            });
        });

        // Funci√≥n auxiliar para escapar HTML y prevenir XSS
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.style.display = 'none';
            });
            document.getElementById(tabName + 'Tab').style.display = 'block';
        }
        
        // Alias para switchTab (para compatibilidad)
        function showTab(tabName) {
            switchTab(tabName);
        }
        
        // Cargar todas las entradas de la base de datos Zotero
        // Funciones para colecciones de Zotero
        let collectionsData = [];
        let selectedCollectionId = null;
        let selectedCollectionName = ''; // Guardar nombre de colecci√≥n seleccionada
        let currentSearchTerm = ''; // Mantener el t√©rmino de b√∫squeda actual

        async function loadCollections() {
            const collectionTree = document.getElementById('collectionTree');
            
            try {
                collectionTree.innerHTML = '<div class="loading">Cargando colecciones...</div>';
                
                const response = await fetch(`${API_BASE}/api/zotero/collections`);
                
                if (!response.ok) {
                    throw new Error(`Error HTTP: ${response.status}`);
                }
                
                const data = await response.json();
                collectionsData = data.collections || [];
                
                console.log('‚úÖ Colecciones cargadas:', collectionsData.length);
                
                if (collectionsData.length === 0) {
                    collectionTree.innerHTML = `
                        <div class="no-results">
                            üìö No se encontraron colecciones
                        </div>
                    `;
                } else {
                    // Solo renderizar las colecciones ra√≠z inicialmente
                    collectionTree.innerHTML = '';
                    renderCollections(collectionsData, collectionTree);
                    console.log('‚úÖ √Årbol renderizado');
                }
                
            } catch (error) {
                console.error('‚ùå Error cargando colecciones:', error);
                collectionTree.innerHTML = `
                    <div class="error-message">
                        Error cargando colecciones: ${escapeHtml(error.message)}
                    </div>
                `;
            }
        }

        function renderCollections(collections, container, level = 0) {
            if (!collections || collections.length === 0) return;
            
            const fragment = document.createDocumentFragment();
            
            collections.forEach(collection => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'tree-item';
                itemDiv.style.marginLeft = (level * 1) + 'rem';
                
                const hasChildren = collection.children && collection.children.length > 0;
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'tree-item-content';
                
                // Icono de expansi√≥n o espacio
                if (hasChildren) {
                    const expandSpan = document.createElement('span');
                    expandSpan.className = 'expand-icon';
                    expandSpan.textContent = '‚ñ∂';
                    expandSpan.style.cursor = 'pointer';
                    expandSpan.style.marginRight = '0.3rem';
                    expandSpan.onclick = (e) => {
                        e.stopPropagation();
                        toggleCollectionChildren(itemDiv, collection.children, level + 1);
                        expandSpan.textContent = expandSpan.textContent === '‚ñ∂' ? '‚ñº' : '‚ñ∂';
                    };
                    contentDiv.appendChild(expandSpan);
                } else {
                    const spacer = document.createElement('span');
                    spacer.style.width = '1.3rem';
                    spacer.style.display = 'inline-block';
                    contentDiv.appendChild(spacer);
                }
                
                // Nombre de la colecci√≥n
                const nameSpan = document.createElement('span');
                nameSpan.textContent = 'üìÅ ' + collection.name;
                nameSpan.style.cursor = 'pointer';
                nameSpan.onclick = (e) => selectCollection(collection.id, collection.name, e.target);
                contentDiv.appendChild(nameSpan);
                
                itemDiv.appendChild(contentDiv);
                fragment.appendChild(itemDiv);
            });
            
            container.appendChild(fragment);
        }

        function toggleCollectionChildren(parentItem, children, level) {
            // Buscar si ya hay un contenedor de hijos
            let childrenContainer = parentItem.nextElementSibling;
            
            if (childrenContainer && childrenContainer.classList.contains('tree-children-container')) {
                // Ya existe, solo toggle la visibilidad
                if (childrenContainer.style.display === 'none') {
                    childrenContainer.style.display = 'block';
                } else {
                    childrenContainer.style.display = 'none';
                }
            } else {
                // No existe, crear y renderizar
                childrenContainer = document.createElement('div');
                childrenContainer.className = 'tree-children-container';
                renderCollections(children, childrenContainer, level);
                parentItem.parentNode.insertBefore(childrenContainer, parentItem.nextSibling);
            }
        }

        async function selectCollection(collectionId, collectionName, eventTarget = null) {
            console.log('=== selectCollection called ===');
            console.log('collectionId:', collectionId);
            console.log('collectionName:', collectionName);
            console.log('currentSearchTerm:', currentSearchTerm);
            
            selectedCollectionId = collectionId;
            selectedCollectionName = collectionName; // Guardar nombre para recargas
            const databaseResults = document.getElementById('databaseResults');
            
            // Resaltar la colecci√≥n seleccionada
            document.querySelectorAll('.tree-item-content').forEach(item => {
                item.classList.remove('selected');
            });
            if (eventTarget) {
                const contentDiv = eventTarget.closest('.tree-item-content');
                if (contentDiv) {
                    contentDiv.classList.add('selected');
                }
            }
            
            try {
                const loadingMsg = currentSearchTerm 
                    ? `Cargando items de "${collectionName}" que coinciden con "${currentSearchTerm}"...`
                    : `Cargando items de "${collectionName}"...`;
                databaseResults.innerHTML = `<div class="loading">${escapeHtml(loadingMsg)}</div>`;
                
                console.log('Fetching items for collection:', collectionId);
                const response = await fetch(`${API_BASE}/api/zotero/collections/${collectionId}/items?includeSubcollections=true`);
                
                if (!response.ok) {
                    throw new Error(`Error HTTP: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Items received:', data.items ? data.items.length : 0);
                let items = data.items || [];
                
                // Aplicar filtro de b√∫squeda si existe
                if (currentSearchTerm) {
                    console.log('Applying filter:', currentSearchTerm);
                    const searchLower = currentSearchTerm.toLowerCase();
                    items = items.filter(item => {
                        const titleMatch = item.title && item.title.toLowerCase().includes(searchLower);
                        const authorsMatch = item.authors && item.authors.toLowerCase().includes(searchLower);
                        const yearMatch = item.year && item.year.toLowerCase().includes(searchLower);
                        return titleMatch || authorsMatch || yearMatch;
                    });
                    console.log('Items after filter:', items.length);
                }
                
                if (items.length === 0) {
                    const noResultsMsg = currentSearchTerm
                        ? `No se encontraron items en "${collectionName}" que coincidan con "${currentSearchTerm}"`
                        : `No se encontraron items en "${collectionName}"`;
                    databaseResults.innerHTML = `
                        <div class="no-results">
                            üìö ${escapeHtml(noResultsMsg)}
                        </div>
                    `;
                } else {
                    renderCollectionItems(items, collectionName, { ...data, total: items.length, withPdf: items.filter(i => i.hasPdf).length });
                }
                
            } catch (error) {
                console.error('‚ùå Error cargando items de colecci√≥n:', error);
                databaseResults.innerHTML = `
                    <div class="error-message">
                        Error cargando items: ${escapeHtml(error.message)}
                    </div>
                `;
            }
        }

        function renderCollectionItems(items, collectionName, stats) {
            const databaseResults = document.getElementById('databaseResults');
            
            const itemsHTML = items.map(item => {
                const safeTitle = escapeHtml(item.title);
                const safeAuthors = escapeHtml(item.authors || 'Desconocido');
                const safeYear = escapeHtml(item.year || 'N/A');
                const safeType = escapeHtml(item.type || 'documento');
                const hasPdf = item.hasPdf;
                const pdfPath = item.pdfPath || item.attachmentPath;
                
                const icon = hasPdf ? 'üìÑ' : '‚ö†Ô∏è';
                const clickAction = hasPdf 
                    ? `onclick="openPdfFromAttachment('${escapeHtml(pdfPath || '')}')"`
                    : '';
                const cursor = hasPdf ? 'pointer' : 'default';
                const titleColor = hasPdf ? '#3498db' : '#999';
                const titleDecoration = hasPdf ? 'underline' : 'none';
                
                return `
                    <div class="result-item" style="cursor: ${cursor};">
                        <div class="result-title" ${clickAction} style="color: ${titleColor}; text-decoration: ${titleDecoration};">
                            ${icon} ${safeTitle}
                        </div>
                        <div class="result-context">
                            <strong>Autores:</strong> ${safeAuthors}<br>
                            <strong>A√±o:</strong> ${safeYear}<br>
                            <strong>Tipo:</strong> ${safeType}
                        </div>
                        <div class="result-path">
                            üóìÔ∏è A√±adido: ${new Date(item.dateAdded).toLocaleDateString()} | 
                            Estado: ${hasPdf ? '‚úÖ Con PDF' : '‚ö†Ô∏è Sin PDF'}
                            ${pdfPath ? `<br>üìÅ ${escapeHtml(pdfPath)}` : ''}
                        </div>
                    </div>
                `;
            }).join('');
            
            // Agregar indicador de filtro activo si existe
            const filterBadge = currentSearchTerm 
                ? `<div style="margin-top: 0.625rem; padding: 0.875rem 1rem; background: #fef8ee; border-left: 3px solid #f0b849; border-radius: 4px; border: 1px solid #f0b849;">
                     üîç Filtrado por: "<strong>${escapeHtml(currentSearchTerm)}</strong>"
                     <button onclick="clearSearchFilter()" style="margin-left: 1rem;">
                       ‚úï Limpiar filtro
                     </button>
                   </div>`
                : '';
            
            databaseResults.innerHTML = `
                <div style="margin-bottom: 1.25rem; padding: 1.25rem; background: #f9f9f9; border-radius: 4px; border: 1px solid #ddd;">
                    <h4 style="margin: 0 0 0.625rem 0; color: #111; font-size: 1.125rem;">üìÅ ${escapeHtml(collectionName)}</h4>
                    <p style="margin: 0; font-size: 0.9375rem; color: #767676;">
                        ${items.length} item${items.length !== 1 ? 's' : ''} 
                        (${stats.withPdf || 0} con PDF, ${items.length - (stats.withPdf || 0)} sin PDF)
                    </p>
                    ${filterBadge}
                </div>
                ${itemsHTML}
            `;
        }
        
        // Funci√≥n para limpiar el filtro de b√∫squeda
        function clearSearchFilter() {
            currentSearchTerm = '';
            const searchInput = document.getElementById('collectionSearch');
            if (searchInput) {
                searchInput.value = '';
            }
            // Recargar la colecci√≥n actualmente seleccionada sin filtro
            if (selectedCollectionId) {
                loadCollections();
            }
        }

        // Filtro de b√∫squeda para colecciones con b√∫squeda en contenido
        const collectionSearchInput = document.getElementById('collectionSearch');
        
        if (collectionSearchInput) {
            collectionSearchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                const searchTerm = e.target.value.trim();
                
                // Guardar t√©rmino de b√∫squeda actual
                currentSearchTerm = searchTerm;
                
                // Si no hay t√©rmino de b√∫squeda, mostrar todo y recargar √°rbol original
                if (!searchTerm) {
                    loadCollections();
                    // Si hay una colecci√≥n seleccionada, recargarla sin filtro
                    if (selectedCollectionId) {
                        reloadCurrentCollection();
                    }
                    return;
                }
                
                // Para t√©rminos cortos (1 car√°cter), solo recargar colecci√≥n si hay una seleccionada
                if (searchTerm.length < 2) {
                    if (selectedCollectionId) {
                        reloadCurrentCollection();
                    }
                    return;
                }
                
                // Debounce para b√∫squeda en servidor (2+ caracteres)
                searchTimeout = setTimeout(() => {
                    // Buscar colecciones que contengan el t√©rmino
                    searchCollectionsByContent(searchTerm);
                }, 300);
                
                // Siempre recargar colecci√≥n actual con el nuevo filtro si hay una seleccionada
                if (selectedCollectionId) {
                    searchTimeout = setTimeout(() => {
                        reloadCurrentCollection();
                    }, 300);
                }
            });
        }
        
        // Funci√≥n auxiliar para recargar la colecci√≥n actual
        async function reloadCurrentCollection() {
            if (!selectedCollectionId || !selectedCollectionName) return;
            await selectCollection(selectedCollectionId, selectedCollectionName);
        }
        
        // Funci√≥n para buscar colecciones por nombre o contenido de items
        async function searchCollectionsByContent(searchTerm) {
            const collectionTree = document.getElementById('collectionTree');
            
            try {
                collectionTree.innerHTML = '<div class="loading">üîç Buscando en colecciones e items...</div>';
                
                const response = await fetch(`${API_BASE}/api/zotero/collections/search?q=${encodeURIComponent(searchTerm)}`);
                
                if (!response.ok) {
                    throw new Error(`Error HTTP: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.collections.length === 0) {
                    collectionTree.innerHTML = `
                        <div class="no-results" style="padding: 1rem; text-align: center; color: #7f8c8d;">
                            No se encontraron colecciones ni items con "${escapeHtml(searchTerm)}"
                        </div>
                    `;
                    return;
                }
                
                // Renderizar resultados de b√∫squeda
                const resultsHTML = data.collections.map(collection => {
                    const matchBadge = collection.matchType === 'name' 
                        ? '<span class="badge">Nombre</span>'
                        : '<span class="badge success">Contenido</span>';
                    
                    const itemCountBadge = collection.itemCount > 0
                        ? `<span style="color: #767676; font-size: 0.875rem; margin-left: 0.5rem;">(${collection.itemCount} items)</span>`
                        : '';
                    
                    return `
                        <div class="tree-item" style="margin: 0.3rem 0;">
                            <div class="tree-item-content" onclick="selectCollection(${collection.id}, '${escapeHtml(collection.name)}', event.target)">
                                üìÅ ${escapeHtml(collection.name)} ${matchBadge} ${itemCountBadge}
                            </div>
                        </div>
                    `;
                }).join('');
                
                collectionTree.innerHTML = `
                    <div style="padding: 1rem; background: #f0f6fc; border-radius: 4px; margin-bottom: 0.625rem; font-size: 0.9375rem; border: 1px solid #0073aa;">
                        <strong style="color: #111;">üîç ${data.collections.length} resultado${data.collections.length !== 1 ? 's' : ''}</strong>
                        <div style="font-size: 0.875rem; color: #767676; margin-top: 0.375rem;">
                            B√∫squeda en nombres y contenido de items
                        </div>
                    </div>
                    ${resultsHTML}
                `;
                
            } catch (error) {
                console.error('Error buscando colecciones:', error);
                collectionTree.innerHTML = `
                    <div class="error-message">
                        Error al buscar: ${escapeHtml(error.message)}
                    </div>
                `;
            }
        }

        async function loadDatabaseEntries() {
            const databaseResults = document.getElementById('databaseResults');
            
            try {
                databaseResults.innerHTML = '<div class="loading">Cargando entradas de la base de datos...</div>';
                
                const response = await fetch(`${API_BASE}/api/zotero/entries?limit=1000`);
                
                if (!response.ok) {
                    throw new Error(`Error HTTP: ${response.status}`);
                }
                
                const data = await response.json();
                const entries = data.entries || [];
                
                if (entries.length === 0) {
                    databaseResults.innerHTML = `
                        <div class="no-results">
                            üìö No se encontraron entradas en la base de datos Zotero
                        </div>
                    `;
                } else {
                    renderDatabaseEntries(entries, data);
                }
                
            } catch (error) {
                console.error('‚ùå Error cargando entradas de base de datos:', error);
                databaseResults.innerHTML = `
                    <div class="error-message">
                        Error cargando entradas de la base de datos: ${error.message}
                    </div>
                `;
            }
        }

        function renderDatabaseEntries(entries, stats) {
            const databaseResults = document.getElementById('databaseResults');
            
            const entriesHTML = entries.map((entry, index) => {
                // Escapar valores para seguridad
                const safeTitle = escapeHtml(entry.title);
                const safeAuthors = escapeHtml(entry.authors || 'Desconocido');
                const safeYear = escapeHtml(entry.year || 'N/A');
                const safeType = escapeHtml(entry.type || 'documento');
                const safeUrl = entry.url ? escapeHtml(entry.url) : '';
                const hasPdf = entry.hasPdf;
                
                // Determinar el icono y comportamiento
                const icon = hasPdf ? 'üìÑ' : (safeUrl ? 'üîó' : '‚ö†Ô∏è');
                const clickAction = hasPdf 
                    ? `onclick="openPdfFromAttachment(${JSON.stringify(entry.attachmentPath || '')})"` 
                    : (safeUrl ? `onclick="window.open(${JSON.stringify(safeUrl)}, '_blank')"` : '');
                const cursor = (hasPdf || safeUrl) ? 'pointer' : 'default';
                const titleColor = (hasPdf || safeUrl) ? '#3498db' : '#999';
                const titleDecoration = (hasPdf || safeUrl) ? 'underline' : 'none';
                
                // Crear el HTML del item
                let itemHTML = `<div class="result-item" style="cursor: ${cursor};">`;
                
                // T√≠tulo - clickeable si tiene PDF o URL
                itemHTML += `
                    <div class="result-title" ${clickAction} style="color: ${titleColor}; text-decoration: ${titleDecoration};">
                        ${icon} ${safeTitle}
                    </div>
                `;
                
                // Informaci√≥n adicional
                itemHTML += `
                    <div class="result-context">
                        <strong>Autores:</strong> ${safeAuthors}<br>
                        <strong>A√±o:</strong> ${safeYear}<br>
                        <strong>Tipo:</strong> ${safeType}
                `;
                
                if (safeUrl && !hasPdf) {
                    itemHTML += `<br><strong>URL:</strong> <a href="${safeUrl}" target="_blank" onclick="event.stopPropagation();" style="color: #3498db;">${safeUrl.substring(0, 80)}${safeUrl.length > 80 ? '...' : ''}</a>`;
                }
                
                itemHTML += `
                    </div>
                    <div class="result-path">
                        üóìÔ∏è A√±adido: ${new Date(entry.dateAdded).toLocaleDateString()} | Estado: ${
                            entry.pdfAvailable ? '‚úÖ PDF disponible en WebDAV' : 
                            (hasPdf ? '‚ö†Ô∏è PDF no sincronizado' : 
                            (safeUrl ? 'ÔøΩÔøΩ URL disponible' : '‚ùå Sin PDF ni URL'))
                        }
                    </div>
                </div>
                `;
                
                return itemHTML;
            }).join('');
            
            databaseResults.innerHTML = `
                <div style="margin-bottom: 1rem; font-size: 0.9rem; color: #7f8c8d;">
                    Se encontraron ${entries.length} entrada${entries.length !== 1 ? 's' : ''} 
                    (${stats.withPdf || 0} con PDF, ${stats.withoutPdf || 0} sin PDF)
                </div>
                ${entriesHTML}
            `;
        }
        
        // Funci√≥n auxiliar para abrir PDF desde la ruta de attachment de Zotero
        async function openPdfFromAttachment(attachmentPath) {
            if (!attachmentPath) {
                alert('No se encontr√≥ la ruta del PDF');
                return;
            }
            
            try {
                console.log('üìÑ Abriendo PDF:', attachmentPath.split('/').pop());
                
                // Usar el nuevo endpoint de resoluci√≥n de rutas
                const response = await fetch(`${API_BASE}/api/resolve-pdf?path=${encodeURIComponent(attachmentPath)}`);
                
                if (!response.ok) {
                    throw new Error(`Error HTTP: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.found && data.cachePath) {
                    console.log('‚úÖ PDF encontrado, abriendo:', data.cachePath);
                    window.open(data.cachePath, '_blank');
                } else {
                    console.error('‚ùå PDF no encontrado:', data);
                    alert("PDF no disponible en WebDAV\n\n" +
                        "Archivo: " + data.filename + "\n\n" +
                        "Este PDF esta registrado pero no disponible en WebDAV.\n\n" +
                        "Solucion:\n" +
                        "1. Sincroniza Zotero Desktop con WebDAV\n" +
                        "2. Verifica sincronizacion de adjuntos\n" +
                        "3. Espera a que se complete la sincronizacion");
                }
                
            } catch (error) {
                console.error('Error abriendo PDF:', error);
                alert(`Error abriendo PDF: ${error.message}`);
            }
        }
        
        // Actualizar estad√≠sticas
        function updateStats(stats) {
            elements.totalPDFs.textContent = stats.totalPDFs || 0;
            elements.indexedPDFs.textContent = stats.indexedPDFs || 0;
            elements.syncStatus.textContent = stats.syncStatus || 'Desconectado';
            
            // √öltima sincronizaci√≥n
            if (stats.lastSync) {
                const lastSync = new Date(stats.lastSync);
                elements.lastSync.textContent = lastSync.toLocaleTimeString('es-ES', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }
            
            // Estado de indexaci√≥n
            if (stats.isIndexing && stats.indexingProgress) {
                elements.syncIndicator.classList.add('indexing');
                elements.syncIndicator.classList.remove('error');
                elements.indexingProgress.style.display = 'block';
                
                const progress = stats.indexingProgress.total > 0 
                    ? (stats.indexingProgress.current / stats.indexingProgress.total) * 100 
                    : 0;
                elements.progressFill.style.width = `${progress}%`;
                elements.progressMessage.textContent = 
                    `Indexando ${stats.currentFile || '...'} (${stats.indexingProgress.current}/${stats.indexingProgress.total})`;
            } else {
                elements.syncIndicator.classList.remove('indexing');
                elements.indexingProgress.style.display = 'none';
            }
        }

        // Detectar desarrollo vs producci√≥n
        function checkDevMode() {
            const isDev = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            if (isDev) {
                elements.apiInfo.style.display = 'block';
                elements.apiInfo.title = 'Modo desarrollo - APIs ocultas disponibles';
            }
        }

        // Inicializar aplicaci√≥n
        function initializeApp() {
            console.log('üöÄ Inicializando aplicaci√≥n v0.2 (REST only)...');
            checkDevMode();
            
            // Sistema simplificado sin Socket.IO
            initializeStats();
            loadCollections();
            initializeTabs();
            initializeTextSearch();
        }
        
        // Inicializar b√∫squeda de texto
        function initializeTextSearch() {
            const textSearchInput = document.getElementById('textSearch');
            if (textSearchInput) {
                textSearchInput.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    const query = e.target.value.trim();
                    
                    if (query.length < 3) {
                        elements.searchResults.innerHTML = '';
                        return;
                    }
                    
                    // Debounce: esperar 500ms despu√©s de que el usuario deje de escribir
                    searchTimeout = setTimeout(() => {
                        performTextSearch(query);
                    }, 500);
                });
            }
        }
        
        // Realizar b√∫squeda de texto
        async function performTextSearch(query) {
            elements.searchResults.innerHTML = '<div class="loading">üîç Buscando...</div>';
            
            try {
                const response = await fetch(`${API_BASE}/api/search?q=${encodeURIComponent(query)}&limit=50`);
                
                if (!response.ok) {
                    throw new Error(`Error HTTP: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.results.length === 0) {
                    elements.searchResults.innerHTML = `
                        <div class="no-results">
                            No se encontraron resultados para "${escapeHtml(query)}"
                        </div>
                    `;
                    return;
                }
                
                // Renderizar resultados
                const resultsHTML = data.results.map(result => {
                    const fileName = result.name || result.file || 'Archivo sin nombre';
                    const preview = result.preview || result.context || '';
                    const score = result.score || 0;
                    
                    return `
                        <div class="result-item" onclick="openFile('${escapeHtml(result.path || result.file || '')}')">
                            <div class="result-title">
                                üìÑ ${escapeHtml(fileName)}
                                ${result.indexed ? '‚úÖ' : '‚è≥'}
                            </div>
                            ${preview ? `<div class="result-context">${escapeHtml(preview)}</div>` : ''}
                            <div class="result-path">
                                üìÅ ${escapeHtml(result.path || '')}
                                ${score > 0 ? ` | Relevancia: ${Math.round(score * 100)}%` : ''}
                            </div>
                        </div>
                    `;
                }).join('');
                
                elements.searchResults.innerHTML = `
                    <div style="margin-bottom: 1.25rem; padding: 1rem; background: #f0f6fc; border-radius: 4px; border: 1px solid #0073aa;">
                        <strong style="color: #111;">üîç ${data.results.length} resultado${data.results.length !== 1 ? 's' : ''}</strong> para "${escapeHtml(query)}"
                    </div>
                    ${resultsHTML}
                `;
                
            } catch (error) {
                console.error('Error en b√∫squeda:', error);
                elements.searchResults.innerHTML = `
                    <div class="error-message">
                        Error al realizar la b√∫squeda: ${escapeHtml(error.message)}
                    </div>
                `;
            }
        }
        
        // Funci√≥n para abrir archivo
        function openFile(filePath) {
            if (!filePath) return;
            
            // Limpiar la ruta
            let cleanPath = filePath.replace('/app/data/biblioteca/', '');
            
            // Construir URL para abrir el PDF
            const pdfUrl = `${API_BASE}/biblioteca/${encodeURIComponent(cleanPath)}`;
            window.open(pdfUrl, '_blank');
        }

        // Inicializar pesta√±as
        function initializeTabs() {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabName = tab.getAttribute('data-tab');
                    showTab(tabName);
                });
            });
        }

        // Manejar errores globales
        window.addEventListener('error', (event) => {
            console.error('‚ùå Error global:', event.error);
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('‚ùå Promesa rechazada:', event.reason);
        });

        // Funci√≥n para iniciar indexaci√≥n OCR
        async function startIndexing() {
            try {
                const btn = document.getElementById('startIndexingBtn');
                btn.disabled = true;
                btn.textContent = '‚è≥ Iniciando...';
                
                const response = await fetch(`${API_BASE}/api/sync`, {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    if (data.isIndexing) {
                        alert(`‚úÖ ${data.message}\n\nSe indexar√°n ${data.toIndex} PDFs con OCR`);
                        startProgressMonitoring();
                    } else {
                        alert(data.message);
                        btn.disabled = false;
                        btn.textContent = 'üöÄ Iniciar Indexaci√≥n OCR';
                    }
                } else {
                    alert(`Error: ${data.error}`);
                    btn.disabled = false;
                    btn.textContent = 'üöÄ Iniciar Indexaci√≥n OCR';
                }
            } catch (error) {
                console.error('Error iniciando indexaci√≥n:', error);
                alert('Error iniciando indexaci√≥n: ' + error.message);
                const btn = document.getElementById('startIndexingBtn');
                btn.disabled = false;
                btn.textContent = 'üöÄ Iniciar Indexaci√≥n OCR';
            }
        }

        let progressInterval = null;

        // Monitorear progreso de indexaci√≥n
        function startProgressMonitoring() {
            const progressDiv = document.getElementById('indexingProgress');
            progressDiv.style.display = 'block';
            
            if (progressInterval) {
                clearInterval(progressInterval);
            }
            
            progressInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE}/api/indexing/progress`);
                    const progress = await response.json();
                    
                    if (progress.isIndexing) {
                        document.getElementById('indexingBar').style.width = progress.percentage + '%';
                        document.getElementById('indexingPercentage').textContent = progress.percentage + '%';
                        document.getElementById('indexingStatus').textContent = 
                            `${progress.current} de ${progress.total} - ${progress.currentFile}`;
                    } else {
                        // Indexaci√≥n completada
                        progressDiv.style.display = 'none';
                        clearInterval(progressInterval);
                        progressInterval = null;
                        
                        const btn = document.getElementById('startIndexingBtn');
                        btn.disabled = false;
                        btn.textContent = 'üöÄ Iniciar Indexaci√≥n OCR';
                        
                        // Recargar estad√≠sticas
                        loadStatsManually();
                        
                        if (progress.current > 0) {
                            alert(`‚úÖ Indexaci√≥n completada!\n\n${progress.current} PDFs indexados con OCR`);
                        }
                    }
                } catch (error) {
                    console.error('Error monitoreando progreso:', error);
                }
            }, 2000); // Cada 2 segundos
        }

        // Inicializar cuando el DOM est√© listo
        document.addEventListener('DOMContentLoaded', initializeApp);
        
        // Recargar datos peri√≥dicamente (REST only)
        setInterval(() => {
            // Sistema REST no necesita verificar Socket.IO
            loadStatsManually();
        }, 30000);
    </script>
</body>
</html>